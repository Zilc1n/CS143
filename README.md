# 编译原理

## 简介
记录Stanford大学CS143编译原理的学习过程:sleeping:

> Cool语法的学习跳过，PA实现在[assignments/PA1/stack.cl](assignments/PA1/stack.cl)

---

## 1. lexer - 词法分析（Lexical Analysis）

在词法分析阶段，我们编写词法分析器的 `flex` 脚本。通过 `flex` 工具，可以将脚本转换为对应的 C++ 源码，进一步编译即可得到可执行的词法分析器（lexer）。

### 词法分析的作用

词法分析器的核心任务是：
**读取源码中的字符流，识别出有意义的单词（token）并分类输出。**

在 `flex` 脚本中，我们主要编写**正则表达式匹配规则**，用于识别源码中的关键词、标识符、常量、运算符等。这些匹配规则最终都会转化为对应的自动机状态跳转表，用于实际运行时识别 token。

lexer 通过正则语法将源码文本转化为一系列 **token**，并在过程中完成基本的语法过滤和错误检测。

### lexer 可以检测的一些明显错误包括：

* **字符串或注释未闭合**（如缺失引号或`*/`）
* **非法字符**（如 ASCII < 32 的控制符号）
* **非法转义字符**（如字符串外的 `\\`）
* **字符串过长**
* **其他可通过字符流直接识别的简单语法错误**

### 一个简单的例子（flex语法）：

```flex
/* 定义词法单元的正则表达式 */
DIGIT     [0-9]
LETTER    [a-zA-Z]
ID        ({LETTER}|{DIGIT}|_)
TYPEID    [A-Z]{ID}*

/* 规则与动作 */
{TYPEID} {
  /* 将识别到的 TYPEID 添加到符号表中 */
  cool_yylval.symbol = idtable.add_string(yytext);
  /* 返回对应的 token 类型 */
  return TYPEID;
}
```

该规则表示：匹配以大写字母开头、后跟若干字母/数字/下划线的类型名，并将其存入符号表。

### 正则表达式与自动机

正则表达式规则虽然简单易写，但它们本身无法直接用于解析字符串。因此需要引入一种可以转化为程序模型的形式 —— **有限自动机（Finite Automaton, FA）**。

> 正则表达式对应的是形式语言中的”正则语言“，表达能力有限，例如匹配括号，无法写出一个正则表达式来匹配任意数量和深度的嵌套括号序列。并且缺乏结构化理解，正则表达式擅长识别扁平的、线性的模式（即一个字符序列）。它们可以告诉你“这里有一个数字”、“那里有一个标识符”、“这里是一个关键字”，但它们无法告诉你这些识别出来的部分之间有什么结构关系，例如无法做到优先级的划分。还有就是无法处理上下文，对于有多义的字符无法来根据上下文进行区分。

#### 有限自动机简介

有限自动机由以下部分组成：

* 状态集合（有限）
* 初始状态
* 接受状态（一个或多个）
* 状态转移函数（基于输入字符，从当前状态跳转到下一个状态）

> 可以把有限自动机看作一个有向图，状态是节点，转移是边。

#### 自动机运行流程：

1. 从初始状态开始
2. 读取输入字符串的每个字符，查找当前状态下的匹配边进行状态转移
3. 如果输入处理完毕后正好落在某个**接受状态**，则该字符串被接受（匹配成功）

#### 两类自动机：

* **确定性有限自动机（DFA）**
  每个状态对每个输入字符最多只有一个转移路径

* **非确定性有限自动机（NFA）**
  允许一个状态对相同字符有多条转移路径，甚至有 ε（空）转移

> DFA 与 NFA 在表达能力上是等价的，NFA 可以通过子集构造法转化为等价的 DFA。


### flex 与自动机的关系

`flex` 工具的核心原理就是**将正则表达式转换为 NFA，再转为 DFA，最后生成状态跳转表**。

生成的代码(lex.yy.cc)大致流程如下：

1. **初始化状态与内存**
2. **读取输入字符（按字节）**
3. **通过 `yy_nxt` 状态表 和 `yy_current_state` 查找转移**
4. **直到无法继续转移为止，确定匹配到的 token**
5. **在 `yy_accept` 表中查找对应的操作 `yy_act` 并执行**

> 其中 `yy_nxt`、`yy_accept` 等状态表是词法分析中由自动机制生成的重要数据结构。


### 总结

词法分析是编译器的第一阶段，通过正则表达式 + 自动机构建出的 lexer 可以：

* 快速识别和分类源代码中的基本单元（token）
* 过滤明显语法错误
* 为后续语法分析阶段（parser）提供基础数据

`flex` 作为一种工具，简化了构建词法分析器的复杂度，使我们只需专注于正则规则的编写，而不必手写自动机代码。